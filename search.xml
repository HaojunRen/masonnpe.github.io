<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[查找算法]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AE%97%E6%B3%95%2F%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找1234567891011121314151617181920212223242526public class BinarySearch &#123; private static int search(int[] arr, int p, int q, int target) &#123; if (p &lt; q) &#123; int mid = (p + q) / 2; if (arr[mid] &gt; target) &#123; return search(arr, p, mid - 1, target); &#125; else if (arr[mid] == target) &#123; return mid; &#125; else &#123; return search(arr, mid + 1, q, target); &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 17, 19&#125;; int index = search(arr, 0,arr.length-1,13); if (index != -1) &#123; System.out.println("下标" + index + "值为" + arr[index]); &#125; else &#123; System.err.println("不存在"); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class BinarySearch &#123; private static int search(int[] arr, int target) &#123; int p = 0; int q = arr.length - 1; while (p &lt; q) &#123; int mid = (p + q) / 2; if (arr[mid] &gt; target) &#123; q = mid - 1; &#125; else if (arr[mid] == target) &#123; return mid; &#125; else &#123; p = mid + 1; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 17, 19&#125;; int index = search(arr, 13); if (index != -1) &#123; System.out.println("下标" + index + "值为" + arr[index]); &#125; else &#123; System.err.println("不存在"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序12345678910111213141516171819202122232425public class BubbleSort &#123; private static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; boolean swapFlag = true; for (int j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapFlag = false; &#125; &#125; if (swapFlag) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 6, 3, 6, 8, 2, 7, 9, 8, 4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 选择排序123456789101112131415161718192021222324public class SelectionSort &#123; private static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 6, 3, 6, 8, 2, 7, 9, 8, 4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 插入排序12345678910111213141516171819public class InsertSort &#123; private static void sort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int last = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; last &lt; arr[j - 1]; j--) &#123; arr[j] = arr[j - 1]; &#125; arr[j] = last; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 6, 3, 6, 8, 2, 7, 9, 8, 4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 12345678910111213141516171819202122public class InsertSort &#123; private static void sort(int[] arr) &#123; int i = 1; while (i &lt; arr.length) &#123; int last = arr[i]; int j = i; while (j &gt; 0 &amp;&amp; last &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; arr[j] = last; i++; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 6, 3, 6, 8, 2, 7, 9, 8, 4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041public class MergeSort &#123; private static void sort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; sort(arr, left, mid, temp);// 左子序列排序 sort(arr, mid + 1, right, temp);// 右子序列排序 merge(arr, left, mid, right, temp);// 合并左右子序列 &#125; &#125; private static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left;// 左子序列指针 int j = mid + 1;// 右子序列指针 int k = 0;// temp指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[k++] = arr[i++]; &#125; if (arr[i] &gt; arr[j]) &#123; temp[k++] = arr[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while (j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; k = 0; while (left &lt;= right) &#123; arr[left++] = temp[k++]; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;1, 6, 3, 6, 8, 2, 7, 9, 8, 4&#125;; sort(arr, 0, arr.length - 1, new int[arr.length]); System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
