<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Masonnpe&#39;s Blog</title>
  
  <subtitle>愿所有的坚持终不被辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://masonnpe.github.io/"/>
  <updated>2018-10-24T16:00:02.446Z</updated>
  <id>https://masonnpe.github.io/</id>
  
  <author>
    <name>Masonnpe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP状态码和首部</title>
    <link href="https://masonnpe.github.io/2018/10/24/%E5%88%86%E5%B8%83%E5%BC%8F/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E9%A6%96%E9%83%A8/"/>
    <id>https://masonnpe.github.io/2018/10/24/分布式/HTTP状态码和首部/</id>
    <published>2018-10-24T15:56:16.432Z</published>
    <updated>2018-10-24T16:00:02.446Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP是一个应用层协议，也是一个无状态的协议，由请求和响应构成，是一个标准的客户端服务器模型。通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">原因短语</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><a id="more"></a><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK</strong> ：客户端请求成功</li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong> ：请求的资源不存在</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">优先的字符集</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">优先的内容编码</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">优先的语言（自然语言）</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">Web 认证信息</td></tr><tr><td style="text-align:center">Expect</td><td style="text-align:center">期待服务器的特定行为</td></tr><tr><td style="text-align:center">From</td><td style="text-align:center">用户的电子邮箱地址</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求资源所在服务器</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">比较实体标记（ETag）</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">比较资源的更新时间</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">比较实体标记（与 If-Match 相反）</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">最大传输逐跳数</td></tr><tr><td style="text-align:center">Proxy-Authorization</td><td style="text-align:center">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">实体的字节范围请求</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:center">TE</td><td style="text-align:center">传输编码的优先级</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">是否接受字节范围请求</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">推算资源创建经过时间</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息让服务端给每一个页面分配一个唯一的编号，通过编号来区分当前这个页面是否是最新的</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">令客户端重定向至指定 URI</td></tr><tr><td style="text-align:center">Proxy-Authenticate</td><td style="text-align:center">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">HTTP 服务器的安装信息</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:center">资源可支持的 HTTP 方法</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">实体主体适用的编码方式</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">实体主体的自然语言</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">实体主体的大小</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">替代对应资源的 URI</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">实体主体的报文摘要</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">实体主体的位置范围</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">实体主体的媒体类型</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">实体主体过期的日期时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源的最后修改日期时间</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP是一个应用层协议，也是一个无状态的协议，由请求和响应构成，是一个标准的客户端服务器模型。通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。&lt;/p&gt;
&lt;h2 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h2&gt;&lt;p&gt;服务器返回的  &lt;strong&gt;响应报文&lt;/strong&gt;  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;状态码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原因短语&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1XX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Informational（信息性状态码）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2XX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Success（成功状态码）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3XX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Redirection（重定向状态码）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4XX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Client Error（客户端错误状态码）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5XX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Server Error（服务器错误状态码）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="HTTP" scheme="https://masonnpe.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名解析</title>
    <link href="https://masonnpe.github.io/2018/10/24/%E5%88%86%E5%B8%83%E5%BC%8F/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>https://masonnpe.github.io/2018/10/24/分布式/DNS域名解析/</id>
    <published>2018-10-24T15:49:46.306Z</published>
    <updated>2018-10-24T15:51:16.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS域名解析流程"><a href="#DNS域名解析流程" class="headerlink" title="DNS域名解析流程"></a>DNS域名解析流程</h2><ol><li>用户输入域名按下回车</li><li>浏览器检查缓存中是否这个域名对应的解析过的IP地址 没有则继续</li><li>查找操作系统缓存 没有则继续</li><li>请求本地域名服务器LDNS 没有则继续</li><li>请求Root DNS Server，返回主域名服务器（gTLD server）地址</li><li>LDNS请求gTLD，gTLD返回Name Server域名服务器的地址 给LDNS</li><li>LDNS查询Name Server 得到IP地址</li><li>LDNS返回IP地址给用户</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DNS域名解析流程&quot;&gt;&lt;a href=&quot;#DNS域名解析流程&quot; class=&quot;headerlink&quot; title=&quot;DNS域名解析流程&quot;&gt;&lt;/a&gt;DNS域名解析流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;用户输入域名按下回车&lt;/li&gt;
&lt;li&gt;浏览器检查缓存中是否这个域名对应的解析过的IP地址 没有则继续&lt;/li&gt;
&lt;li&gt;查找操作系统缓存 没有则继续&lt;/li&gt;
&lt;li&gt;请求本地域名服务器LDNS 没有则继续&lt;/li&gt;
&lt;li&gt;请求Root DNS Server，返回主域名服务器（gTLD server）地址&lt;/li&gt;
&lt;li&gt;LDNS请求gTLD，gTLD返回Name Server域名服务器的地址 给LDNS&lt;/li&gt;
&lt;li&gt;LDNS查询Name Server 得到IP地址&lt;/li&gt;
&lt;li&gt;LDNS返回IP地址给用户&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="DNS" scheme="https://masonnpe.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://masonnpe.github.io/2018/10/24/%E5%88%86%E5%B8%83%E5%BC%8F/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://masonnpe.github.io/2018/10/24/分布式/TCP协议/</id>
    <published>2018-10-24T15:32:28.983Z</published>
    <updated>2018-10-24T15:33:23.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h2><p>对于TCP通信来说，每个Socket的内核中都有一个发送缓冲区和一个接收缓冲区，TCP的全双工的工作模式及TCP的滑动窗口就是依赖于这两个独立的缓冲区和缓冲区填充状态。 </p><p>接收缓冲区把数据缓存到内核，若应用进程一直没有调用Socket的read方法进行读取，那么该数据会一直被缓存在接收缓冲区内，不管进程是否读取Socket，对发送端发来的数据都会经过内核接收并缓存到Socket的内核接受缓冲区。</p><a id="more"></a><h2 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="首部格式"></p><p><strong>序号seq</strong>：用于对字节流进行编号，例如序号为 101，表示第一个字节的编号为 101，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 201。</p><p><strong>确认号ack</strong>：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>确认ACK</strong>：当 ACK=1 时确认号字段有效，否则无效。TCP 规定在连接建立后所有传送的报文段都必须把 ACK 置 1。</p><p><strong>同步SYN</strong>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p><p><strong>终止FIN</strong>：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p><p><strong>窗口</strong>：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><!--more--><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p><strong>第一次握手</strong>：Client 向 Server 发送连接请求报文SYN=1，随机产生一个值seq= x给Server，Client 进入SYN_SENT状态，等待Server确认。</p><p><strong>第二次握手</strong>：Server 收到连接请求报文，由标志位SYN=1知道Client请求建立连接,Server 向Client 发送连接确认报文SYN=1，ACK=1，seq为 x+1，同时随机产生一个值seq= y,Server进入SYN_RCVD状态</p><p><strong>第三次握手</strong>：Client 收到 Server  的连接确认报文后,检查ACK是否为1，ack是否为x+1,如果正确则还要向 Server  发出确认，ack为 y+1,将标志位ACK置为1。Server检查ack是否为y+1,ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，开始传输数据。</p><blockquote><p>SYN攻击时一种典型的DDOS攻击，就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p></blockquote><h3 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h3><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中延迟，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="四次挥手"></p><p><strong>第一次挥手</strong>：Client 发送连接释放报文，FIN=1，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p><strong>第二次挥手</strong>：Server 收到FIN后之后发出确认，此时 TCP 属于半关闭状态，Server  能向 Client 发送数据但是 Client  不能向 Server  发送数据。发送一个ACK给Client，ack为u+1后进入CLOSE_WAIT状态。</p><p><strong>第三次挥手</strong>：当Server 不再需要连接时，发送连接释放报文，FIN=1用来关闭Server到Client的数据传送，Server进入LAST_ACK状态</p><p><strong>第四次挥手</strong>：Client 收到后FIN后进入 TIME-WAIT 状态，发出确认，等待 2 MSL（最大报文存活时间）后释放连接。Server  收到 Client  的确认后进入CLOSED状态</p><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由</p><ul><li>确保最后一个确认报文能够到达。如果Server  没收到Client 发送来的确认报文，那么就会重新发送连接释放请求报文，Client  等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt="滑动窗口"></p><h3 id="超时重发"><a href="#超时重发" class="headerlink" title="超时重发"></a>超时重发</h3><p>当发送者向接收者发包后，如果过了一段时间(超时时间)依然没有收到消息，就当做本次包丢失，需要重新补发。并且如果一次性发了三个包，只要最后一个包确认收到之后就默认前面两个也收到了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP通信原理&quot;&gt;&lt;a href=&quot;#TCP通信原理&quot; class=&quot;headerlink&quot; title=&quot;TCP通信原理&quot;&gt;&lt;/a&gt;TCP通信原理&lt;/h2&gt;&lt;p&gt;对于TCP通信来说，每个Socket的内核中都有一个发送缓冲区和一个接收缓冲区，TCP的全双工的工作模式及TCP的滑动窗口就是依赖于这两个独立的缓冲区和缓冲区填充状态。 &lt;/p&gt;
&lt;p&gt;接收缓冲区把数据缓存到内核，若应用进程一直没有调用Socket的read方法进行读取，那么该数据会一直被缓存在接收缓冲区内，不管进程是否读取Socket，对发送端发来的数据都会经过内核接收并缓存到Socket的内核接受缓冲区。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="TCP" scheme="https://masonnpe.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile语法</title>
    <link href="https://masonnpe.github.io/2018/10/24/Docker/Dockerfile%E8%AF%AD%E6%B3%95/"/>
    <id>https://masonnpe.github.io/2018/10/24/Docker/Dockerfile语法/</id>
    <published>2018-10-24T12:25:46.450Z</published>
    <updated>2018-10-24T14:34:39.797Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch <span class="comment"># 制作baseimage</span></span><br><span class="line"><span class="keyword">FROM</span> centos <span class="comment"># 使用baseimage</span></span><br><span class="line"><span class="keyword">LABEL</span> version="1.0" # 定义metadata</span><br><span class="line">RUN set -ex; # 执行命令并创建新的imagelayer</span><br><span class="line">WORKDIR demo # 创建目录并进入，默认根目录/test</span><br><span class="line">ADD hello / # 将本地文件添加到里面</span><br><span class="line">ADD test.tar.gz / # 添加到根目录并解压</span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/ # 添加文件，但不能解压</span><br><span class="line">ENV GOSU_VERSION 1.7 # 设置常量  使用$GOSU_VERSION引用常量</span><br><span class="line">VOLUME /var/lib/mysql # 存储</span><br><span class="line">EXPOSE 3306 33060 # 网络</span><br><span class="line">CMD ["mysqld"] # 设置容器启动后默认执行的命令和参数</span><br><span class="line">ENTRYPOINT ["docker-entrypoint.sh"] # 设置容器启动时运行的命令</span><br></pre></td></tr></table></figure><p><a href="https://github.com/docker-library/" target="_blank" rel="noopener">docker-library</a>里有官方收录的Dockerfile，可以作为参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imagename path # 构建image</span><br><span class="line">docker run imagename # 运行</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; scratch &lt;span class=&quot;comment&quot;&gt;# 制作baseimage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; centos &lt;span class=&quot;comment&quot;&gt;# 使用baseimage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;LABEL&lt;/span&gt; version=&quot;1.0&quot; # 定义metadata&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN set -ex; # 执行命令并创建新的imagelayer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WORKDIR demo # 创建目录并进入，默认根目录/test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD hello / # 将本地文件添加到里面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD test.tar.gz / # 添加到根目录并解压&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COPY docker-entrypoint.sh /usr/local/bin/ # 添加文件，但不能解压&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENV GOSU_VERSION 1.7 # 设置常量  使用$GOSU_VERSION引用常量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;VOLUME /var/lib/mysql # 存储&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXPOSE 3306 33060 # 网络&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMD [&quot;mysqld&quot;] # 设置容器启动后默认执行的命令和参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] # 设置容器启动时运行的命令&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/docker-library/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker-library&lt;/a&gt;里有官方收录的Dockerfile，可以作为参考&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build -t imagename path # 构建image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run imagename # 运行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://masonnpe.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://masonnpe.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker简介</title>
    <link href="https://masonnpe.github.io/2018/10/23/Docker/Docker%E7%AE%80%E4%BB%8B/"/>
    <id>https://masonnpe.github.io/2018/10/23/Docker/Docker简介/</id>
    <published>2018-10-23T14:03:17.976Z</published>
    <updated>2018-10-23T15:30:16.977Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过Docker可以将程序运行的环境也纳入到版本控制中，解决一些项目交付时的麻烦。</p><p><img src="http://pgmrhouhm.bkt.clouddn.com/docker%E6%9E%B6%E6%9E%84.jpg" alt="docker架构"></p><h2 id="底层技术支持"><a href="#底层技术支持" class="headerlink" title="底层技术支持"></a>底层技术支持</h2><p>Namespaces：通过Linux的Namespaces对不同的容器实现了隔离，包括进程、网络等信息。通过挂载点映射和宿主机的目录。</p><p>ControlGroups：隔离宿主机器上的物理资源，例如CPU、内存、磁盘I/O和网络带宽。</p><p>UnionFileSystems：container和image的分层。</p><a id="more"></a><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>可以使用<code>docker images ls</code>命令查看本机的image</p><ul><li><p>文件和metadata的集合</p></li><li><p>分层，每层都可以添加、改变、删除文件</p></li><li><p>image本身是只读的</p></li></ul><p><strong>获取方式</strong></p><ul><li>可以通过Dockerfile构建自己的image，使用<code>docker build</code>获取image</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><ul><li><code>docker pull rabbitmq:management</code>拉取image</li></ul><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><p>可以使用<code>docker container ls</code>命令查看本机的container </p><ul><li>通过image创建</li><li>类比面向对象：image是类，container是实例</li><li>负责运行</li></ul><p><code>docker run -it xxx</code> 可以进container里面进行一些操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过Docker可以将程序运行的环境也纳入到版本控制中，解决一些项目交付时的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pgmrhouhm.bkt.clouddn.com/docker%E6%9E%B6%E6%9E%84.jpg&quot; alt=&quot;docker架构&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;底层技术支持&quot;&gt;&lt;a href=&quot;#底层技术支持&quot; class=&quot;headerlink&quot; title=&quot;底层技术支持&quot;&gt;&lt;/a&gt;底层技术支持&lt;/h2&gt;&lt;p&gt;Namespaces：通过Linux的Namespaces对不同的容器实现了隔离，包括进程、网络等信息。通过挂载点映射和宿主机的目录。&lt;/p&gt;
&lt;p&gt;ControlGroups：隔离宿主机器上的物理资源，例如CPU、内存、磁盘I/O和网络带宽。&lt;/p&gt;
&lt;p&gt;UnionFileSystems：container和image的分层。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://masonnpe.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://masonnpe.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS环境下安装Docker</title>
    <link href="https://masonnpe.github.io/2018/10/23/Docker/CentOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Docker/"/>
    <id>https://masonnpe.github.io/2018/10/23/Docker/CentOS环境下安装Docker/</id>
    <published>2018-10-23T13:25:01.305Z</published>
    <updated>2018-10-23T14:00:00.540Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">官方安装文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">           docker-client \</span><br><span class="line">           docker-client-latest \</span><br><span class="line">           docker-common \</span><br><span class="line">           docker-latest \</span><br><span class="line">           docker-latest-logrotate \</span><br><span class="line">           docker-logrotate \</span><br><span class="line">           docker-selinux \</span><br><span class="line">           docker-engine-selinux \</span><br><span class="line">           docker-engine</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce</span><br><span class="line">systemctl start docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><a id="more"></a><p>也可以使用阿里的镜像，将第二步指令替换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方安装文档&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum remove docker \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-client \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-client-latest \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-common \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-latest \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-latest-logrotate \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-logrotate \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-selinux \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-engine-selinux \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           docker-engine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y docker-ce&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl start docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://masonnpe.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://masonnpe.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="https://masonnpe.github.io/2018/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>https://masonnpe.github.io/2018/10/22/数据库/数据库锁/</id>
    <published>2018-10-22T15:49:53.298Z</published>
    <updated>2018-10-22T15:57:43.868Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th>共享锁(S)</th><th>排他锁(X)</th><th>意向共享锁(IS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td><strong>共享锁</strong></td><td>兼容</td><td>冲突</td><td>兼容</td><td>冲突</td></tr><tr><td><strong>排他锁</strong></td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td><strong>意向共享锁</strong></td><td>兼容</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td><strong>意向排他锁</strong></td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;共享锁(S)&lt;/th&gt;
&lt;th&gt;排他锁(X)&lt;/th&gt;
&lt;th&gt;意向共享锁(IS)&lt;/th&gt;
&lt;th&gt;意向排他锁(IX)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;共享锁&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;排他锁&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;意向共享锁&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;意向排他锁&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;td&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://masonnpe.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Lock" scheme="https://masonnpe.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎</title>
    <link href="https://masonnpe.github.io/2018/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
    <id>https://masonnpe.github.io/2018/10/22/数据库/数据库引擎/</id>
    <published>2018-10-22T15:42:35.973Z</published>
    <updated>2018-10-22T15:57:39.520Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th>Innodb</th><th>Myisam</th></tr></thead><tbody><tr><td>存储文件</td><td>.frm表定义文件 ibd数据文件</td><td>.frm表定义文件 .myd数据文件 .myi索引文件</td></tr><tr><td>锁</td><td>表锁、行锁</td><td>表锁</td></tr><tr><td>事务</td><td>ACID</td><td>不支持</td></tr><tr><td>CURD</td><td>读、写</td><td>读多</td></tr><tr><td>count</td><td>扫表</td><td>专门存储的地方</td></tr><tr><td>索引结构</td><td>B+Tree</td><td>B+Tree</td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Innodb&lt;/th&gt;
&lt;th&gt;Myisam&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存储文件&lt;/td&gt;
&lt;td&gt;.frm表定义文件 ibd数据文件&lt;/td&gt;
&lt;td&gt;.frm表定义文件 .myd数据文件 .myi索引文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;锁&lt;/td&gt;
&lt;td&gt;表锁、行锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;事务&lt;/td&gt;
&lt;td&gt;ACID&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CURD&lt;/td&gt;
&lt;td&gt;读、写&lt;/td&gt;
&lt;td&gt;读多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count&lt;/td&gt;
&lt;td&gt;扫表&lt;/td&gt;
&lt;td&gt;专门存储的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;索引结构&lt;/td&gt;
&lt;td&gt;B+Tree&lt;/td&gt;
&lt;td&gt;B+Tree&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://masonnpe.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Innodb" scheme="https://masonnpe.github.io/tags/Innodb/"/>
    
      <category term="Myisam" scheme="https://masonnpe.github.io/tags/Myisam/"/>
    
  </entry>
  
  <entry>
    <title>BASE理论</title>
    <link href="https://masonnpe.github.io/2018/10/22/%E5%88%86%E5%B8%83%E5%BC%8F/BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://masonnpe.github.io/2018/10/22/分布式/BASE理论/</id>
    <published>2018-10-22T15:19:41.257Z</published>
    <updated>2018-10-22T15:31:04.162Z</updated>
    
    <content type="html"><![CDATA[<p>BASE理论是对CAP理论中一致性和可用性权衡的结果，如果无法做到强一致性，那就要采取合适的方法使系统达到最终一致性。传统的数据库系统要求强一致性(ACID)，BASE理论强调通过牺牲强一致性来达到可用性。在实际业务场景中，要结合业务对一致性的要求，将ACID和BASE结合起来使用。</p><h2 id="基本可用-BasicallyAvailable"><a href="#基本可用-BasicallyAvailable" class="headerlink" title="基本可用(BasicallyAvailable)"></a>基本可用(BasicallyAvailable)</h2><p>分布式系统在出现故障的时候，保证核心功能可用，允许损失部分可用性。</p><h2 id="软状态-SoftState"><a href="#软状态-SoftState" class="headerlink" title="软状态(SoftState)"></a>软状态(SoftState)</h2><p>允许系统中的数据存在中间状态，即系统不同节点的数据副本之间进行同步的过程存在时间延迟</p><h2 id="最终一致性-EventuallyConsistent"><a href="#最终一致性-EventuallyConsistent" class="headerlink" title="最终一致性(EventuallyConsistent)"></a>最终一致性(EventuallyConsistent)</h2><p>系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BASE理论是对CAP理论中一致性和可用性权衡的结果，如果无法做到强一致性，那就要采取合适的方法使系统达到最终一致性。传统的数据库系统要求强一致性(ACID)，BASE理论强调通过牺牲强一致性来达到可用性。在实际业务场景中，要结合业务对一致性的要求，将ACID和BASE结合起来使用。&lt;/p&gt;
&lt;h2 id=&quot;基本可用-BasicallyAvailable&quot;&gt;&lt;a href=&quot;#基本可用-BasicallyAvailable&quot; class=&quot;headerlink&quot; title=&quot;基本可用(BasicallyAvailable)&quot;&gt;&lt;/a&gt;基本可用(BasicallyAvailable)&lt;/h2&gt;&lt;p&gt;分布式系统在出现故障的时候，保证核心功能可用，允许损失部分可用性。&lt;/p&gt;
&lt;h2 id=&quot;软状态-SoftState&quot;&gt;&lt;a href=&quot;#软状态-SoftState&quot; class=&quot;headerlink&quot; title=&quot;软状态(SoftState)&quot;&gt;&lt;/a&gt;软状态(SoftState)&lt;/h2&gt;&lt;p&gt;允许系统中的数据存在中间状态，即系统不同节点的数据副本之间进行同步的过程存在时间延迟&lt;/p&gt;
&lt;h2 id=&quot;最终一致性-EventuallyConsistent&quot;&gt;&lt;a href=&quot;#最终一致性-EventuallyConsistent&quot; class=&quot;headerlink&quot; title=&quot;最终一致性(EventuallyConsistent)&quot;&gt;&lt;/a&gt;最终一致性(EventuallyConsistent)&lt;/h2&gt;&lt;p&gt;系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="BASE" scheme="https://masonnpe.github.io/tags/BASE/"/>
    
  </entry>
  
  <entry>
    <title>CAP理论</title>
    <link href="https://masonnpe.github.io/2018/10/22/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E7%90%86%E8%AE%BA/"/>
    <id>https://masonnpe.github.io/2018/10/22/分布式/CAP理论/</id>
    <published>2018-10-22T15:19:10.566Z</published>
    <updated>2018-10-22T15:19:29.244Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统不可能同时满足一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)，最多只能同时满足其中两项，这就是CAP理论。在分布式系统中分区容忍性必不可少，所以CAP理论实际上是要在可用性和一致性之间做取舍。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>多个数据副本能保持一致，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。如果系统的一个数据更新成功之后，所有用户都能够读取到最新的值，系统就被认为具有强一致性。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>分布式系统在面对各种异常时都可以提供正常服务，对于用户的每一个操作、请求总是能够在有限的时间内返回结果。</p><h2 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h2><p>分布式系统在遇到任何网络分区故障的时候，仍然能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式系统不可能同时满足一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)，最多只能同时满足其中两项，这就是CAP理论。在分布式系统中分区容忍性必不可少，所以CAP理论实际上是要在可用性和一致性之间做取舍。&lt;/p&gt;
&lt;h2 id=&quot;一致性&quot;&gt;&lt;a href=&quot;#一致性&quot; class=&quot;headerlink&quot; title=&quot;一致性&quot;&gt;&lt;/a&gt;一致性&lt;/h2&gt;&lt;p&gt;多个数据副本能保持一致，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。如果系统的一个数据更新成功之后，所有用户都能够读取到最新的值，系统就被认为具有强一致性。&lt;/p&gt;
&lt;h2 id=&quot;可用性&quot;&gt;&lt;a href=&quot;#可用性&quot; class=&quot;headerlink&quot; title=&quot;可用性&quot;&gt;&lt;/a&gt;可用性&lt;/h2&gt;&lt;p&gt;分布式系统在面对各种异常时都可以提供正常服务，对于用户的每一个操作、请求总是能够在有限的时间内返回结果。&lt;/p&gt;
&lt;h2 id=&quot;分区容忍性&quot;&gt;&lt;a href=&quot;#分区容忍性&quot; class=&quot;headerlink&quot; title=&quot;分区容忍性&quot;&gt;&lt;/a&gt;分区容忍性&lt;/h2&gt;&lt;p&gt;分布式系统在遇到任何网络分区故障的时候，仍然能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="CAP" scheme="https://masonnpe.github.io/tags/CAP/"/>
    
  </entry>
  
</feed>
